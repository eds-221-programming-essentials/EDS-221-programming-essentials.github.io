---
title: "Day 5: Tasks & activities - KEY"
subtitle: "Functions, sourcing scripts, working on your R package"
editor_options: 
  chunk_output_type: console
---

```{r}
#| include: false
#| warning: false
#| message: false
library(tidyverse)
```

## Estimate storm runoff volume

One established way to calculate the volume of stormwater expected for a watershed (necessary to design best management practices & systems) is the *Simple Method*, which involves two steps. First, the runoff coefficient $R_v$ (storm runoff/storm rainfall) is calculated from: 

$$R_v = 0.05 + 0.9 * I_A$$ 

Where $R_v$ is the runoff coefficient (unitless), and $I_A$ is the fraction of the watershed that is considered "impervious" (unitless).

The volume of stormwater that needs to be handled, $V$ in cubic feet, is then calculated by: 

$$V=3630 * R_D * R_v * A$$
where $R_D$ is the "*design storm rainfall depth*" in inches, usually set to 1.0 or 1.5, $R_v$ is the runoff coefficient calculated above, and $A$ is the watershed area in acres. 

1. Create a function called `predict_runoff` that estimates the storm runoff volume using inputs for the impervious fraction and watershed area (you can use a constant value of 1 for $R_D$ here)

::: {.callout-important}
## Solution
```{r}
predict_runoff <- function(frac_impervious, watershed_area) {
  
  ifelse(frac_impervious <= 1, TRUE, stop("NOPE"))
  
  runoff_coef <- 0.05 + 0.9 * frac_impervious
  runoff_volume <- 3630 * 1.0 * {runoff_coef} * watershed_area
  print(runoff_volume)
}
```


```{r}
#' Estimate storm runoff volume
#'
#' @param frac_impervious 
#' @param watershed_area 
#'
#' @returns runoff_volume
#' @export
#'
#' @examples
#' 
predict_runoff <- function(frac_impervious, watershed_area) {
  
  ifelse(frac_impervious <= 1, TRUE, stop("NOPE"))
  
  runoff_coef <- 0.05 + 0.9 * frac_impervious
  runoff_volume <- 3630 * 1.0 * {runoff_coef} * watershed_area
  print(runoff_volume)
}
```

:::

2. Source your `storm_runoff.R` script so you are able to use the `predict_runoff` function in your `.Rmd`

::: {.callout-important}
## Solution

```{r}
#| eval: false
source(here::here("storm_runoff.R"))
```
:::

3. In a code chunk in your `runoff_volumes.Rmd`, use your `predict_runoff` function to estimate stormwater volume for a watershed of 182 acres, over a range of estimates for the impervious fraction (from 0.6 to 0.8, by increments of 0.01)

::: {.callout-important}
## Solution
```{r}
# Make the sequence of impervious fractions
impervious_sequence <- seq(from = 0.6, to = 0.8, by = 0.01)

# Make predictions for volume at all values of impervious fraction, for watershed area = 182
val <- predict_runoff(frac_impervious = impervious_sequence, watershed_area = 182)
```
:::

4. Bind into a data frame

::: {.callout-important}
## Solution
```{r}
runoff_df <- data.frame(impervious_sequence, val)
```
:::

5. Create a ggplot graph that has both dots and connecting lines (i.e., you'll layer `geom_point()` and `geom_line()`). Update axis labels. Export a png of your graph to the `figs` folder using `ggsave`.

::: {.callout-important}
## Solution
```{r}
ggplot(data = runoff_df, aes(x = impervious_sequence, y = val)) +
  geom_point() +
  geom_line() +
  theme_minimal() +
  labs(x = "Fraction impervious surface in the watershed",
       y = "Expected runoff volume (cubic feet)")
```
:::


## Tilapia imports in the US

1. Read in the data as `us_tilapia_imports` 

::: {.callout-important}
## Solution
```{r}
#| eval: false

us_tilapia_imports <- read_csv(here::here("data", "us_tilapia_imports.csv"))
```

```{r}
#| include: false
#| message: false
#| warning: false

us_tilapia_imports <- read_csv(here::here("course-materials", "eod-practice", "data", "us_tilapia_imports.csv"))
```

```{r}
names(us_tilapia_imports) # Check variable names
dim(us_tilapia_imports)  # Check number of rows and columns
```
:::

2. Use `pivot_longer()` to reshape the data into long format and coerce the year column to `numeric`

::: {.callout-important}
## Solution
```{r}
us_tilapia_imports_long <- us_tilapia_imports |> 
  pivot_longer(cols = '1992':'2018', 
               names_to = 'year', 
               values_to = 'tilapia_volume_kpounds') |> 
  mutate(year = as.numeric(year))
```
:::

3. Use `dplyr::group_by() %>% summarize()` to find the *total* US tilapia imports by *year*, store as `yearly_tilapia_tot`

::: {.callout-important}
## Solution
```{r}
yearly_tilapia_tot <- us_tilapia_imports_long |>  
  group_by(year) |> 
  summarize(annual_total = sum(tilapia_volume_kpounds, na.rm = TRUE))
```
:::

4. Create a ggplot line graph of total US tilapia imports for all years in `yearly_tilapia_tot`. Update axis labels (include units as necessary), then export your graph as a .png to `figs`

::: {.callout-important}
## Solution
```{r}
ggplot(data = yearly_tilapia_tot, aes(x = year, y = annual_total)) +
  geom_line()
```
:::

5. Create a subset that only retains imports from Ecuador, Honduras, Costa Rica, and Mexico

::: {.callout-important}
## Solution
```{r}
limited_us_tilapia <- us_tilapia_imports_long |> 
  filter(country %in% c("Ecuador", "Honduras", "Costa Rica", "Mexico"))
```
:::

6. Create a ggplot graph of total US tilapia imports over time, for those four countries in the subset you created above, separated by country. Update axis labels, add a title, customize your color scheme, update the theme. Export a .jpg of your graph to `figs`

::: {.callout-important}
## Solution
```{r}
#| warning: false
ggplot(data = limited_us_tilapia, 
       aes(x = year, y = tilapia_volume_kpounds)) +
  geom_point(aes(color = country))
```
:::
